1. **Apache Kafka**: Kafka is a distributed streaming platform that is designed to handle real-time data feeds. It is horizontally scalable, fault-tolerant, and incredibly fast, which makes it suitable for streaming and processing large volumes of data in real-time. Kafka works well in use cases such as tracking website activity, monitoring IoT data, and real-time analytics. For example, LinkedIn uses Kafka for tracking user activity data and operational metrics.

2. **RabbitMQ**: RabbitMQ is a traditional message broker that supports several messaging protocols. It excels in scenarios where you need to ensure that a message is delivered at least once, or where the publisher and consumer have to work at different rates. It’s used for tasks ranging from queuing tasks for background processing to balancing loads in web applications. For instance, Instagram uses RabbitMQ for feed and "like" updates.

3. **Amazon SQS (Simple Queue Service)**: Amazon SQS is a fully managed message queuing service that enables you to decouple and scale microservices, distributed systems, and serverless applications. SQS eliminates the complexity and overhead associated with managing and operating message oriented middleware. It's best used when you are working within AWS ecosystem, and for scenarios where the order of events is not crucial. For example, an e-commerce application could use SQS to queue orders that are then processed by a separate service.

4. **Google Pub/Sub**: Google Cloud Pub/Sub is an asynchronous messaging service that decouples services that produce events from services that process events. It's a scalable, durable event ingestion and delivery system that serves as a foundation for modern stream analytics pipelines. Best used in event-driven architectures and real-time analytics, especially within Google Cloud. For instance, Spotify uses Google Pub/Sub for its event delivery needs.

5. **ActiveMQ**: Apache ActiveMQ is a widely used message-oriented middleware that provides high availability and performance. It supports many cross-language clients and protocols, and offers enterprise features. It's suitable for use cases where you need a full-fledged, feature-rich message broker, and particularly for Java applications.

6. **NATS**: NATS is a simple, high performance open source messaging system for cloud-native applications, IoT messaging, and microservices architectures. It's lightweight and easy to deploy, and it doesn't require a high memory footprint. Its design philosophy is "fire and forget," which means it doesn't handle storing messages if consumers are offline. 
   
   NATS is particularly strong in use cases where you need high speed and volume with low latency, and where message delivery doesn't need to be guaranteed – for instance, in real-time systems, sensor data, or live updates. NATS is used extensively in cloud platforms, distributed systems, and real-time analytics. For example, it's a key component in the Cloud Foundry platform.
   
   Compared to systems like Kafka or RabbitMQ, NATS is simpler and more lightweight, but it's less suitable for situations where you need features like message persistence, guaranteed delivery, or in-order delivery. It doesn't provide these out of the box, as it's designed for speed and simplicity rather than feature richness. It's best suited for use cases where the loss of a few messages is acceptable.
